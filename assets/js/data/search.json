[ { "title": "Detection of Venation Intersections in Bee Wings", "url": "/posts/imed/", "categories": "School Projects, Image Processing", "tags": "IMAGE, IMED, TIFO", "date": "2021-08-15 00:00:00 +0200", "snippet": "Image processing, Image DetectionProjectThe goal of this project was to find an algorithms pipeline that would get thevenation intersection detected. Microscopic images and some ground truth weregi...", "content": "Image processing, Image DetectionProjectThe goal of this project was to find an algorithms pipeline that would get thevenation intersection detected. Microscopic images and some ground truth weregiven, but purposely not enough not for deep learning to be used. Here are a sample of given pictures with their ground truthChosen Solution Sato filter to highlight the venation Enhance and select highlighted venation with morphology Morphological reconstruction Skeletonize the result to ease corner detection Results at each step of the pipeline Corner detection with Harris corner detector Postprocessing to remove points too close from eachother (avoid duplicates) Result of raw corner detection and after post processing Final results for the 5 pictures with ground truth. The calculated average F-Scoreis 0.809" }, { "title": "Coding a Ray Tracer", "url": "/posts/isim/", "categories": "School Projects, Image Processing", "tags": "IMAGE, ISIM", "date": "2021-05-04 00:00:00 +0200", "snippet": "Ray Tracer, Ray Tracing, Image Modeling, Phong Model, Image RenderingSubjectFor this course project, the goal was to do something with a personalimplementation of a ray tracer.My base implementatio...", "content": "Ray Tracer, Ray Tracing, Image Modeling, Phong Model, Image RenderingSubjectFor this course project, the goal was to do something with a personalimplementation of a ray tracer.My base implementation was able to render objects in space like those spheres:ProjectI decided to implement the support of heightmaps,by creating them randomly with adiamond-squarealgorithm and discretizing their complex form into smaller ones (triangles) toease the ray tracing process.This pipeline can give this kind of output:Performances EnhancementThe problem for creating visualy attractive maps, is that a lot of triangles arerequired, and therefore the computation time increases a lot. To counter this, Ifound a trick to ignore most of the triangles during the ray tracing process.I decided to consider maps as a cuboids:Then, the cuboid could act as a hitbox and give interesting informations on theray that was launched during calculations, esentially where it was entering andexiting the cuboid:In the end, it reduces the number of triangles to check when searching whichobjects in the scene get intersected by the launched ray of light.I did some benchmarks, which showed that this method was indeed speeding up thecomputation process:Final ResultsFinally, I was able to have those results, with maps containing millions oftriangles:" }, { "title": "Classifying Pixels of Hyperspectral Images", "url": "/posts/iml/", "categories": "School Projects, Image Processing", "tags": "IMAGE, IML", "date": "2021-05-04 00:00:00 +0200", "snippet": "Hyperspectral Image, Classification, Machine LearningSubjectFor this project, we had to propose an image processing pipeline to classifypixels in hyperspectral images of crops. Two images and their...", "content": "Hyperspectral Image, Classification, Machine LearningSubjectFor this project, we had to propose an image processing pipeline to classifypixels in hyperspectral images of crops. Two images and their ground truth weregiven: Those images have 200 and 204 spectral bands, respectively.Visualizing hyperspectral images in RGB is not complicated, the onlymanipulaiton needed is to select images at the corresponding spectralbands (30, 15 and 2 here)PipelinePreprocessingFirst of all, the more bands there is, the more the classifying process will belong and complicated; in this sense, the application of aPCA processingwhich led to dividing by (at least) 2 the number of dimensions by pixel (numberbands).ClassificationThen, we have tested a lot of classifying methods: SVMs, Random Forests, KMeans,Spectral Clustering, Hierarchical Clustering, MeanShift, Gaussian methods… Butthe two bests we came up with were the Nu-Support Vector Classification(NuSVC)and the Random ForestClassifier.During testing phase, we took every pixels into account, but we should haveonly taken pixels that were not from class 0 (null class, no crop, notclassified)The training set represents 80% of the data, the test set 20%. The training setis used for the training process, the test set is used after training andrepresents data that was never seen by the classifier before the end of itstraining. ACCURACY Training Set Test Set Mean (reconstuted image) NuSVC 0.855 0.785 0.841 Random Forest 0.999 0.738 0.947 NuSVC result Random Forest resultThe table shows that the NuSVC has slightly better results on data it has neverseen than the Random Forest, even though the latter performed better on thetraining set: the Random Forest overfits too much the data it sees.PostprocessingWhen we look at those resulting image, we can see holes in the fields, and spotsin the non classified regions: it really looks like noise on an image. So, weapplied mathematical morphology. To be more precised, we applied mathematicalmorphology operations class by class, to avoid fields to fuse together and keepthe non-classified delimitations in place. ACCURACY Reconstructed Image NuSVC 0.866 Random Forest 0.985 NuSVC final results Random Forest final resultsThe mean accuracy of both classifier increased with the postprocessing, but theone of the Random Forest really pumped. This final trick was really adapted toits output." }, { "title": "Barcode Detection on GPU", "url": "/posts/gpgpu/", "categories": "School Projects, Image Processing", "tags": "IMAGE, IRGPU", "date": "2021-04-12 00:00:00 +0200", "snippet": "CUDA, GPU Programming, Detection, Image ProcessingProjectImplementing Local Binary PatternsHitogramsalgorithm on GPU, then get the resulting images in a KMeans to extract a classcontaining all pixe...", "content": "CUDA, GPU Programming, Detection, Image ProcessingProjectImplementing Local Binary PatternsHitogramsalgorithm on GPU, then get the resulting images in a KMeans to extract a classcontaining all pixels related to the barcode.Various images were given, bellow an example of input image:LBPThe LBP is a simple yet very efficient textureoperator which labels the pixels of an image by thresholding the neighborhood ofeach pixel and considers the result as a binary number: LBP algorithm detailed (Image from Towards Data Science)HistogramsAfter calculating each pixel new value with LBP, the next step was to divide theimage in patches, and calculate the patches’ histograms. Each histogram is anentry to the following classification step. Histogram part detailed (Image from Towards Data Science)GPU ImplementationThe final strategy has been to launch only one kernel that would load a patch(16x16 pixels + borders needed to have neighboorhood) in shared memory and applythe LBP algorithm, finishing each thread job with a direct update of the histogram.This histogram update need an atomic operation, as multiple thread could bemodifying the same value at the same time. Therefore, the depicted method was abit slower than a more straight forward one, without the use of shared memory.However, the memory is managed more properly and the implementation of a strategylike parallel reduction to avoid atomics could be a great improvement.Classification ResultsResulting histograms are handed over to a pretrained KMeans (with clusters centersalready known) with arbitrary number of classes (here 16, which should be enough) Results of histograms classificationHere we can see in which classes each patch was classified. Testing withmultiple images, including some without barcode, the 12th class stands out as aquite good detection of the barcode." } ]
